#Marmalade

Marmalade is a literate programming environment. It is written in Marmalade, using Clojure as the interpretation environment and [metacircular](http://en.wikipedia.org/wiki/Meta-circular_evaluator) bootstrap. 

Marmalade is a dialect of Git-Flavored Markdown. As such, Marmalade could be written in [many languages](https://github.com/github/linguist/blob/master/lib/linguist/languages.yml) while still being written in Marmalade. I chose Clojure out of familiarity, and because Instaparse is fun to work with. 

Literate programming is due for a revival. Any program running in the browser contains at least three languages, HTML, CSS, and Javascript. Often, these are actually generated by template languages and JS-targeting compilers, further muddying the waters.

On the server side, even a simple application often has at least three languages involved, before we start to count binaries that are used alongside the custom logic. A Ruby core, some Python string handling, a bit of Java for the database layer, a JS JSON widget on Node, perhaps some Clojure, a crypto layer written in some flavor of C, and it goes on: there are the configuration languages and shell scripts to be considered. 

There are no real best practices for keeping this all in a canonical form that is reference, documentation, rationale, bibliography and source, all in one package. Hence, a Git-Flavored literary Markdown project. 

##Literate Programming

Literate programming is conceptually straightforward: your source code consists both of documentation and source code, proper. One program, the weaver, produces a document from the source code. Another program, the tangler, produces code suitable for compilation. 

Our stack has a third program, the detangler: it takes changes in the weave and attempts to back-propagate them into the source. I feel as though this is the missing element in existing literate environments: it is easier, often, to modify code in-place, especially with languages that have a REPL. We want to be able to pull those changes back into the source, to be further rearranged if desired. 

Because of macros, this can't always be done predictably. Marmion, our detangler, will be smart enough to know when it can't incorporate changes, or when the source was modified in ways it can't follow. 

##Athena

Athena is our weaver. We will be using Jekyll for most of the heavy lifting at first, so Athena will do some macro expansion and streamlining and emit Markdown at first. Later, we will bring [enlive](https://github.com/cgrand/enlive) into the mix and start emitting HTML directly. Because HTML embeds directly into Markdown, Athena may always emit .md, which is in many ways the more flexible format of the two. 

We intend to do some cool things with Athena, in particular embedding line-by-line links to the tangle in the weave, adding ASCIIMathML support, and a few other tricks. There's a JS-driven REPL for almost any language, and we could add interactivity where it makes sense. 

For projects that target a browser, the line between a tangle and a weave is somewhat blurred. Athena and the tangler, Arachne, will share a certain amount of code, and Marmion will be able to draw from the weave as well if, say, we embed code editors directly into it. 

I'm editing Marmalade from Github at the moment, so that's a plausible thing to do. 

##Arachne

Arachne is the first crucial tool. Markdown parsers are commonplace, though none quite so Olympian in name. Literate Markdown is also not a new idea. [Literate Coffeescript](http://coffeescript.org/#literate) is officially supported by the core language and widely considered a good idea.

It isn't "real" literate programming, because the code order is physical, not logical. A literate Coffeescript file compiles to one Coffeescript file, the contents of which is exactly and only the ```` ```coffee ```` code found within.

No big deal. It fits the philosophy of the language and I wouldn't expect or want this to change. Marmalade's just a different jam.

Zeus, our bootstrap, is a slight refinement on this: it has just enough magic-word capability kludged in to generate multiple source files from a single Markdown document. This was a pleasureable, slightly manic weekend project.

It was necessary because Zeus is written in Clojure, which typically wants a certain structure for a project, and uses Instaparse, which has its own grammar format. This is the source file for Marmalade alpha, which will be massaged into shape from the bootstrap. 

Fun, huh?

Since then, I've made substantial alterations to the Markdown parser. It currently looks like this:

```

(* A Grammar for Marmalade, A Literate Flavour of Markdown *)


marmalade = &header section+ | paragraph + section * ;

section = header paragraph + line*;

<line> = !(header | triple-ticks) #'[^\n]+' (!blank-line '\n')*;

<block> = line+ ;

<paragraph> = prose | code ;

header = "#" #'[^\n]+' '\n'+; 

prose = block blank-line+ ;

code = code-header code-body code-footer ;

code-body = (line | blank-line)+ ;
 
<blank-line> = '\n' sp #'[\n]+' ;

code-header = triple-ticks (code-type)* "\n" ;

code-footer = triple-ticks ws; 

<sp> = #'[ \t]*' ;

<ws> = #'[\s]+';

code-type = "clojure" | "text" ;

<triple-ticks> = "`" "`" "`" ;

magic = "`@" magic-word "@`" ;

magic-word = #'[^@]+' ; 
```

Although it's much prettier in Sublime Text.

The next step is to start to define our macros. 

##Literate Macros

The term macro generally refers to a function that rewrites code prior to any attempt to make sense of it. Whether Coffeescript is a macro preprocessor over Javascript or a language in its own right is a matter of taste. Macros can get arbitrarily complex. We will keep ours as simple as practical. 

Our simplest type of macro is an anchor. It is surrounded with a triglyph on both sides, e.g. ` ~<$macro$>~ `, where the triglyph selected is one that will not appear in either order in the target language.

Second rule: if the triglyphs are `~<$` and `$>~`, then `$><$` must also be an invalid token in the targeted language. We will use this rule for chaining macros.

We will provide a mechanism for defining macro glyphs in the ```` ```config ```` blocks, later. For now we're hard wiring them. Marmalade has one, which I won't type until the code is sanitized to allow literal quoting of the macro form. The Clojure macros are `#|(` and `)|#` with the tetraglyph form `)||(`. They are syntax errors and likely to stay so. If it turns into anything legitimate, it will be a block quote a la Common Lisp. Rich has declared his opposition. 

It's quite possible to write a legit Marmalade file that doesn't use any Markdown macros. Without macros in the code blocks, there will be no tangle. The default behavior around a code block with no macros is to include it in the weave but not the tangle. Often this is what we want, if we are quoting a short piece of code that never gets used or that has been deprecated in favor of better code. 



