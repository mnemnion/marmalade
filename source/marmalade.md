#Marmalade

Marmalade is a literate programming environment. It is written in Marmalade, using Clojure as the interpretation environment and [metacircular](http://en.wikipedia.org/wiki/Meta-circular_evaluator) bootstrap.

Marmalade is a dialect of Git-Flavored Markdown. As such, Marmalade could be written in [many languages](https://github.com/github/linguist/blob/master/lib/linguist/languages.yml) while still being written in Marmalade. I chose Clojure out of familiarity, and because Instaparse is fun to work with.

Literate programming is due for a revival. Any program running in the browser contains at least three languages, HTML, CSS, and Javascript. Often, these are actually generated by template languages and JS-targeting compilers, further muddying the waters.

On the server side, even a simple application often has at least three languages involved, before we start to count binaries that are used alongside the custom logic. A Ruby core, some Python string handling, a bit of Java for the database layer, a JS JSON widget on Node, perhaps some Clojure, a crypto layer written in some flavor of C, and it goes on: there are the configuration languages and shell scripts to be considered.

There are no real best practices for keeping this all in a canonical form that is reference, documentation, rationale, bibliography and source, all in one package. Hence, a Git-Flavored literary Markdown project.

##Literate Programming

Literate programming is conceptually straightforward: your source code consists both of documentation and source code, proper. One program, the weaver, produces a document from the source code. Another program, the tangler, produces code suitable for compilation.

Our stack has a third program, the detangler: it takes changes in the weave and attempts to back-propagate them into the source. I feel as though this is the missing element in existing literate environments: it is easier, often, to modify code in-place, especially with languages that have a REPL. We want to be able to pull those changes back into the source, to be further rearranged if desired.

Because of macros, this can't always be done predictably. Marmion, our detangler, will be smart enough to know when it can't incorporate changes, or when the source was modified in ways it can't follow.

##Athena

[Athena](athena/athena.md) is our weaver. We will be using Jekyll for most of the heavy lifting at first, so Athena will do some macro expansion and streamlining and emit Markdown at first. Later, we will bring [enlive](https://github.com/cgrand/enlive) into the mix and start emitting HTML directly. Because HTML embeds directly into Markdown, Athena may always emit .md, which is in many ways the more flexible format of the two.

We intend to do some cool things with Athena, in particular embedding line-by-line links to the tangle in the weave, adding ASCIIMathML support, and a few other tricks. There's a JS-driven REPL for almost any language, and we could add interactivity where it makes sense.

For projects that target a browser, the line between a tangle and a weave is somewhat blurred. Athena and the tangler, Arachne, will share a certain amount of code, and Marmion will be able to draw from the weave as well if, say, we embed code editors directly into it.

I'm editing Marmalade from Github at the moment, so that's a plausible thing to do.

##Arachne

[Arachne](arachne/arachne.md) is the first crucial tool. Markdown parsers are commonplace, though none quite so Olympian in name. Literate Markdown is also not a new idea. [Literate Coffeescript](http://coffeescript.org/#literate) is officially supported by the core language and widely considered a good idea.

It isn't "real" literate programming, because the code order is physical, not logical. A literate Coffeescript file compiles to one Coffeescript file, the contents of which is exactly and only the ```` ```coffee ```` code found within.

No big deal. It fits the philosophy of the language and I wouldn't expect or want this to change. Marmalade's just a different jam.

Zeus, our bootstrap, is a slight refinement on this: it has just enough magic-word capability kludged in to generate multiple source files from a single Markdown document. This was a pleasureable, slightly manic weekend project.

It was necessary because Zeus is written in Clojure, which typically wants a certain structure for a project, and uses Instaparse, which has its own grammar format. This is the source file for Marmalade alpha, which will be massaged into shape from the bootstrap.

Fun, huh?

Since then, I've made substantial alterations to the Markdown parser. It currently looks like this:

```
(* A Grammar for Marmalade, A Literate Flavour of Markdown *)

marmalade = &header section+ | paragraph + section * ;

section = header paragraph + line*;

<line> = !(header | triple-ticks) #'[^\n]+' (!blank-line '\n')*;

<block> = line+ ;

<paragraph> = prose | code ;

header = "#" #'[^\n]+' '\n'+;

prose = block blank-line+ ;

code = code-header code-body code-footer ;

code-body = (code-line | blank-line)+ ;

<code-line> = !(triple-ticks) #'[^\n]+' (!blank-line '\n')* ;

<blank-line> = '\n' sp #'[\n]+' ;

code-header = triple-ticks (code-type)* "\n"+ ;

code-footer = triple-ticks ws;

<sp> = #'[ \t]*' ;

<ws> = #'[\s]+';

code-type = "clojure" | "text" ;

<triple-ticks> = "`" "`" "`" ;
```

Although it's much prettier in Sublime Text.

The next step is to start to define our macros.

##Literate Macros

The term macro generally refers to a function that rewrites code prior to any attempt to make sense of it. Whether Coffeescript is a macro preprocessor over Javascript or a language in its own right is a matter of taste. Macros can get arbitrarily complex. We will keep ours as simple as practical.

Our simplest type of macro is an anchor. It is surrounded with a triglyph on both sides, e.g. ` ~<$macro$>~ `, where the triglyph selected is one that will not appear in either order in the target language.

Second rule: if the triglyphs are `~<$` and `$>~`, then `$><$` must also be an invalid token in the targeted language. We will use this rule for chaining macros. Those are also the default triglyphs in code blocks, if none are provided.

We will provide a mechanism for defining macro glyphs in the ```` ```config ```` blocks, later. For now we're hard wiring them. Marmalade has one, which I won't type until the code is sanitized to allow literal quoting of the macro form. The Clojure macros are `#|(` and `)|#` with the tetraglyph form `)||(`. They are syntax errors and likely to stay so. If it turns into anything legitimate, it will be a block comment a la Common Lisp. Rich has declared his opposition.

It's quite possible to write a legit Marmalade file that doesn't use any Markdown macros. Without macros in the code blocks, there will be no tangle. The default behavior around a code block with no macros is to include it in the weave but not the tangle. Often this is what we want, if we are quoting a short piece of code that never gets used or that has been deprecated in favor of better code.

Anchor macros have an interior syntax. The simplest takes the form ` ~<$name$>~ `. The typical use is as a point in code for macro expansion. If so, Arachne will attempt to fill the macro from a code block called `~<$source:name$>~`. `source` is a keyword, not a variable.

Another keyword form is `~<$file:/src/file.extn$>~`. Any code block containing such a macro at the top will end up in that file, after all other macros are fully expanded.

There is a short continuation form used to intersperse code and commentary. Let's say we're targeting foo-lang, and we have declared a ```` ```foo-lang ```` block that has started a file. If the next foo-lang block looks like ```` ```foo-lang~ ```` with a `~` after it, that block continues in the same file.

Each language may be considered namespaced in this regard, so if you are interweaving two or more languages, each will go into the current file. Try to keep things easy to follow.

###Macro Predicates

In addition, a macro may have a prefix, which is an ordinary symbol which must end in the character `?`. In the configuration, the prefix may be set to 'true' or 'false'. If the prefix is false, the macro doesn't exist.

This is a simple `#ifdef` kind of refinement that lets use build multiple versions from a single codebase.

I am wary of adding more complexity than this.

##Implementing Macros

Our Markdown "parser" doesn't do much, on purpose. It splits things up into prose and code, taking 18 ms to parse this file at the moment on my Macbook. That's good, source has a way of getting large and we'd like file IO to be the limiting factor. Holding it all in memory shouldn't be a challenge, but we'll `spit` files out and flush them from memory as soon as they're complete, just in case we're trying to build an operating system or something.

In order to find things like macros, we'll use a helper function called `re-parse`. This might find its way into the Instaparse core eventually, for now, here's what we need in one chunk.

```clojure
(defn- e-tree-seq
  "tree-seqs enlive trees/graphs, at least instaparse ones"
  [e-tree]
  (if (map? (first e-tree))
      (tree-seq (comp seq :content) :content (first e-tree))
      (tree-seq (comp seq :content) :content e-tree)))

(defn- flatten-enlive
  "flattens an enlive tree (instaparse dialect)"
  [tree]
  (apply str (filter string? (e-tree-seq tree))))

(defn- flatten-hiccup
  "flattens a hiccup tree (instparse dialect)"
  [tree]
  (apply str (filter string? (flatten tree))))

(defn re-parse
  "[parser tree (:rule)]
  Re-parse an instaparse tree with a parser
  If :rule is given, re-parse only those nodes matching
  :rule."
  ([parser tree]
  (if (vector? tree)
         (insta/parse parser (flatten-hiccup tree))
         (insta/parse parser (flatten-enlive tree))))
  ([parser tree rule]
  (if (vector? tree)
         (insta/transform {rule (fn [& node] (re-parse parser [rule node]))} tree)
         (insta/transform {rule (fn [& node] (re-parse parser {:tag rule, :content node}))} tree))))
```

Looks good. Added 5 ms to the parse.

`re-parse` takes a tree, which can be a node of a larger tree, and re-parses it. It can use the same grammar, or in our case, a different one.

This will be nice when it comes time to make sense of our `:prose` as well. For now we're focused on code. We will soon need to delve into the prose to find links to follow: Arachne, called on the top file of a project, does the rest.

For now, let's define a grammar that will capture our Clojure macros. When that works, we'll add some Markdown macros, a `re-parse` for the prose, and then we can really get cooking.

```
(* A Mini Grammar for Literate Clojure Macros in Marmalade *)

code-body = (code-line | blank-line)+ ;

<code-line> = (#'[^\n#|(]+' | macro | punc) (!blank-line '\n')* ;

macro = <mac-start> mac-name <mac-end> ;

<mac-start> = '#|(' ;

<mac-name> = !mac-end #'[^)]+' ;

<mac-end> = ')|#' ;

<punc> = !mac-start #'[#|(]+' ;

<blank-line> = '\n' sp #'[\n]+' ;

<sp> = #'[ \t]*' ;

<ws> = #'[\s]+';

```

This would appear to do it. We will parse the macro body later. Note that, once we find the macro begins and ends, we discard them. Arachne discards what she doesn't need, as Athena will do as well.

So now we can find macros inside Clojure code, and we have at least an idea of how we're going to find macros inside arbitrary code. The `mac-start` and `mac-end` rules can be overridden, I think, using the parser combinator forms. We can certainly concatenate a string containing the new rules to the grammar string and roll our own parser on demand.

From Arachne's perspective, the codes are what matter. The prose needs to be crawled for internal links that contain more Marmalade, which we'll do soon.

In the meantime, we have to actually get at the macros. We need some more helper functions.

```clojure
#|(Helper Functions)|#
(defn tag-stripper
  "strips :tag from tree"
  [tag parse-tree]
  (let [seq-tree (e-tree-seq parse-tree)]
    (filter #(= tag (:tag %))
            seq-tree)))

(defn code-type
  "expects a :code tree. Returns the type of the code,
as a string, or \\n if not found."
  [tree]
  (first (:content (first (:content tree)))))
```

Here's a block that's for some macros:

```clojure
#|(macro:with/a/file.txt)|#
#|(prefix?macro:with-a-name)|#
#|(ordinary macro with whitespace)|# ;this may not be allowed.
```

Let's try that out. Looks good! Also, happily, Pygments/Linguist tags the `|` as an error in the macros, giving them a distinctive look.

We need a little micro-grammar to parse it:

```
(* A Micro Grammar For Macros *)

mac-name = prefix? command ':' mac-id
         | mac-id
         ;

prefix = #'[0-9A-Za-z.!+\- ]+\?'

mac-id = #'[0-9A-Za-z.!+\-_/ ]*'
         ;

command = #'[0-9A-Za-z.!+\-_ ]+'
          ;
```

Which works, except we may want to normalize whitespace. Or simply disallow it outside of file names, where it may be required.

Athena will eventually emit the HTML for highlighted code blocks directly. That will allow us to highlight macros in a distinctive color, and make them into links within the weave which lead to their definitions or to whatever other place makes sense. Later, we'll want to add line-links into the online repo.

Another advantage of doing this could be that Athena could be tuned to emit Markdown, rather than the Git flavor. GFM is widely supported but Markdown itself is practically lingua franca.

That will require thoughtful data types. The challenge of a good syntax highlighter is this: we want to be able to write color themes that will work with everything. Alas, concepts are not equivalent across programming languages.

Since this is a parser-driven highlight, we will likely end up with something like major and minor modes for color themes. Every language grammar will come with a map from the tags in the grammar onto a default set of names for programming concepts, kind of like the TextMate domain. Every color theme must cover all these names (they can inherit from other themes in this respect) and may in addition provide minor modes for languages in which overriding color tags are provided directly.

There is also absolutely no reason we shouldn't correctly highlight embedded code. Let's say a language contains an inline facility for C. We can specify that region to be highlighted using the C engine. A page conflating HTML, CSS and JS into a single text file could be correctly marked up. It won't even be particularly challenging. `re-parse` is a cool little function.

##Link Hunter

Arachne has some work to do in our :prose as well. Most links are not her business, rather Athena's. Arachne does need to look in any local links for more source code that may contain weavable code blocks.

Arachne won't look for these kinds of links in headers, only in :prose blocks. Let's write a little `re-parse` grammar to find these kinds of links.

Currently there's a behavior in the grammar that prevents the last line from being part of the paragraph. I've tagged it as :last-line, so we can `transform` it into :prose.

What we need to do:

  1. Parse the head file
  1. Parse and follow all interior links
  1. Parse the files thereby found
  1. Parse all code blocks for macros
  1. Expand said macros into file strings
  1. Spit out the file strings into the tangle.

Pretty much, that's the job. I'm curious to see what our Marmalade parser will do with that list. Should be :prose (it is).
